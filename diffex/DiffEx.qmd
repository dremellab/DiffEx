---
title: "Differential Gene Expression Analysis"
format:
  html:
    theme: flatly
    toc: true
    toc-location: left
    toc-depth: 4
execute:
  echo: false
  warning: false
  message: true
params:
  counts_file: ".test/counts_matrix.tsv"
  samplesheet: ".test/samples.tsv"
  normalization_method: "TMM" # Normalization method can be TMM or ERCC
  group1: "WT_72h"
  group2: "WT_3d"
  sample_column: "sampleName"
  group_column: "groupName"
  design_formula: "~ groupName"
  normalized_counts_file: "normalized_counts.tsv"
  deg_results_file: "deg_results.tsv"
  log2FC_threshold: 1
  pvalue_threshold: 0.05
---

# üî¨ Differential Expression Analysis

This report performs standard DGE analysis using input count data, metadata, and user-defined contrasts.

---
```{r library}
#| code-fold: true
#| code-summary: "üì¶ Load Required Packages"
suppressPackageStartupMessages({
  library(limma)
  library(edgeR)
  library(tibble)
  library(readr)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(plotly)
  library(EnhancedVolcano)
  library(knitr)
  library(kableExtra)
  library(ggplotify)
  library(ggpubr)
  library(ggrepel)
  library(openxlsx)
  library(glue)
  library(DT)
})
```

```{r readinput}
#| code-fold: true
#| code-summary: "üì• Read Count Matrix and Sample Sheet"
#| message: true
#| warning: false
counts <- read.table(params$counts_file,
                     check.names = FALSE,  # prevent automatic conversion of hyphen to dot
                     row.names = 1, 
                     sep = "\t", 
                     header = TRUE)

# Report original dimensions
print(glue::glue("üìä Counts matrix loaded: ", nrow(counts), " genes (rows) √ó ", ncol(counts), " samples (columns)"))

# Replace hyphens with underscores in column names
colnames(counts) <- gsub("-", "_", colnames(counts))

# Read the sample sheet
samples <- read.table(params$samplesheet, check.names = FALSE, sep = "\t", header = TRUE)
drop_cols <- intersect(c("path_to_R1_fastq", "path_to_R2_fastq"), colnames(samples))
samples <- dplyr::select(samples, -all_of(drop_cols))

# Validate required columns exist
required_cols <- c(params$sample_column, params$group_column)
missing_cols <- setdiff(required_cols, colnames(samples))

if (length(missing_cols) > 0) {
  stop("‚ùå The following required column(s) are missing from the samplesheet:\n",
       paste(missing_cols, collapse = ", "))
}

# Cleanup column values
samples[[params$sample_column]] <- gsub("-", "_", samples[[params$sample_column]])
samples[[params$group_column]]  <- gsub("-", "_", samples[[params$group_column]])
```

```{r normalizationcheck}
#| code-fold: true
#| code-summary: "üîç Check for Normalization Method"
#| message: true
#| warning: false
#| 
# ‚úÖ Normalization method check
normalization_method <- tolower(params$normalization)

if (normalization_method == "ercc") {
  ercc_genes <- grep("^ERCC-", rownames(counts), value = TRUE)
  num_ercc <- length(ercc_genes)
  
  if (num_ercc == 0) {
    stop("‚ùå Normalization method is ERCC but no genes starting with 'ERCC-' were found in the counts matrix.")
  } else {
    print(glue::glue("üß™ ERCC normalization selected: Found ", num_ercc, " ERCC spike-in genes."))
  }

} else if (normalization_method == "tmm") {
  print(glue::glue("üìè TMM normalization selected."))
  
} else {
  stop("‚ùå Invalid normalization method: ", params$normalization,
       "\nSupported methods: 'ERCC' or 'TMM'")
}
```

```{r validateinput}
#| code-fold: true
#| code-summary: "‚úÖ Validate Contrast Groups"
#| message: true
#| warning: false
# Check unique group levels in the samplesheet
valid_groups <- unique(samples[[params$group_column]])

# Get groups from params
g1 <- params$group1
g2 <- params$group2

# Find missing groups
missing_groups <- setdiff(c(g1, g2), valid_groups)

if (length(missing_groups) > 0) {
  stop(paste0("‚ùå Group(s) from params not found in samples[[params$group_column]]\n",
       paste(missing_groups, collapse = ", ")))
} else {
  print(glue::glue("‚úÖ Both group1 and group2 are present in samplesheet."))
  
  # Check if each group has at least 2 samples
  group_counts <- table(samples$groupName)
  too_few <- c()
  if (group_counts[g1] < 2) too_few <- c(too_few, g1)
  if (group_counts[g2] < 2) too_few <- c(too_few, g2)
  
  if (length(too_few) > 0) {
    stop("‚ùå The following group(s) have fewer than 2 samples:\n",
         paste(too_few, collapse = ", "))
  } else {
    print(glue::glue("‚úÖ Each group has at least 2 samples."))
  }
}

```

```{r filtercounts}
#| code-fold: true
#| code-summary: "üéØ Filter samples and counts matrix for selected groups"
#| message: true
#| warning: false

# Filter the samplesheet to only include samples from group1 and group2
selected_samples <- samples[samples[[params$group_column]] %in% c(g1, g2), ]

# Get the sample IDs (assuming there's a 'sample' column)
sample_ids <- selected_samples$sample

# Now subset the counts matrix
# Ensure sample columns in counts match sample IDs
filtered_counts <- counts[, colnames(counts) %in% sample_ids]
# Report dimensions
print(glue::glue("üì¶ Filtered counts matrix: ", nrow(filtered_counts), " genes √ó ", ncol(filtered_counts), " samples"))
```

```{r setupdge}
#| code-fold: true
#| code-summary: "üß¨ Set up DGE object"
#| message: true
#| warning: false
group <- factor(selected_samples[[params$group_column]], levels = c(g1, g2))

if (normalization_method == "ercc") {
  print(glue::glue("üß™ ERCC normalization selected"))

  # Identify ERCC genes
  ercc_rows <- grep("^ERCC-", rownames(counts))
  if (length(ercc_rows) == 0) stop("‚ùå No ERCC spike-ins found in the counts matrix.")

  # Separate ERCC and endogenous counts
  ercc_counts <- counts[ercc_rows, ]
  endogenous_counts <- counts[-ercc_rows, ]

  # ERCC normalization
  dge_ercc <- DGEList(counts = ercc_counts)
  dge_ercc <- calcNormFactors(dge_ercc, method = "TMM")

  # Apply ERCC-derived normalization factors
  dge <- DGEList(counts = endogenous_counts, group = group)
  dge$samples$norm.factors <- dge_ercc$samples$norm.factors

} else if (normalization_method == "tmm") {
  print(glue::glue("üìè TMM normalization selected"))

  dge <- DGEList(counts = counts, group = group)
  dge <- calcNormFactors(dge, method = "TMM")

} else {
  stop("‚ùå Unsupported normalization method: ", params$normalization,
       "\nPlease use either 'ERCC' or 'TMM'")
}

# Filter low-count genes
keep <- filterByExpr(dge)
filtered_out <- sum(!keep)
remaining <- sum(keep)
dge <- dge[keep, , keep.lib.sizes = FALSE]

# Report filtering results
print(glue::glue("üîç Filtered out ", filtered_out, " low-count genes."))
print(glue::glue("‚úÖ Remaining genes for analysis: ", remaining))
```

```{r save_normalized_counts}
#| code-fold: true
#| code-summary: "üíæ Save Normalized Counts"
#| message: true
#| warning: false
# Save normalized counts to a file
normalized_counts <- cpm(dge, normalized.lib.sizes = TRUE)
write.table(normalized_counts, 
            file = params$normalized_counts_file, 
            sep = "\t", 
            quote = FALSE, 
            col.names = TRUE, 
            row.names = TRUE)
print(glue::glue("üíæ Normalized counts saved to: ", params$normalized_counts_file))
```

```{r sample_table}
#| code-fold: true
#| code-summary: "üìã Sample Metadata with Library Sizes and Norm Factors"
#| warning: false
#| message: false

library(dplyr)
library(knitr)

# Extract sample info from dge object
sample_info <- dge$samples %>%
  tibble::rownames_to_column(var = "Sample") %>%
  mutate(
    Group = group,
    LibrarySize = format(lib.size, big.mark = ","),
    NormFactor = signif(norm.factors, 3)
  ) %>%
  select(Sample, Group, LibrarySize, NormFactor)

# Display table
kable(
  sample_info,
  # caption = "Sample metadata with group, library size, and normalization scaling factor",
  col.names = c("Sample", "Group", "Library Size", "Norm Factor"),
  align = "lrlr",
  format = "html"
)

DT::datatable(
  sample_info,
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ),
  rownames = FALSE
)
```


# üìä Data Visualization
## Normalized counts Distribution plot

```{r plot_counts_violin_by_sample}
#| code-fold: true
#| code-summary: "üéª Violin Plot of Normalized Counts by Sample (Colored by Group)"
#| fig.width: 10
#| fig.height: 6
#| fig.cap: "Violin plot of normalized counts by sample, colored by group"
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false

# Define color palette based on actual group names
group_colors <- setNames(c("#0072B2", "#D55E00"), c(g1, g2))

# Prepare data
violin_data <- as.data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") %>%
  pivot_longer(-gene, names_to = "sample", values_to = "normalized_counts")

violin_data$group <- selected_samples[[params$group_column]][match(violin_data$sample, selected_samples[[params$sample_column]])]
violin_data$group <- factor(violin_data$group, levels = c(g1, g2))
violin_data$sample <- factor(violin_data$sample, levels = unique(violin_data$sample))
violin_data$normalized_counts <- as.numeric(violin_data$normalized_counts)
violin_data <- violin_data %>% filter(normalized_counts > 0)

# Plot
violin_plot <- ggplot(violin_data, aes(x = sample, y = normalized_counts, fill = group)) +
  geom_violin(scale = "width", trim = TRUE, alpha = 0.7) +
  geom_boxplot(width = 0.1, outlier.shape = 16, outlier.size = 1, alpha = 0.5) +
  scale_y_log10() +
  scale_fill_manual(values = group_colors) +
  theme_bw() +
  labs(
    title = "Violin Plot of Normalized Counts by Sample (log10)",
    x = "Sample",
    y = "Normalized Counts (log10 scale)",
    fill = "Group"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    legend.position = "top"
  )

print(violin_plot)
```


## 2-D PCA plot

```{r plot_pca_plotly}
#| code-fold: true
#| code-summary: "üß¨ PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 6
#| fig.cap: "PCA plot of normalized counts (colored by group)"
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

# Perform PCA
pca <- prcomp(t(normalized_counts), center = TRUE, scale. = TRUE)
pca_data <- as.data.frame(pca$x)

# Calculate % variance explained
pca_var <- pca$sdev^2
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)

# Add group and sample info
pca_data$sample <- rownames(pca_data)
pca_data$group <- selected_samples[[params$group_column]][match(pca_data$sample, selected_samples[[params$sample_column]])]
pca_data$group <- factor(pca_data$group, levels = c(g1, g2))

# Create custom hover text
pca_data$hover <- paste0(
  "Sample: ", pca_data$sample,
  "<br>Group: ", pca_data$group,
  "<br>PC1: ", round(pca_data$PC1, 2),
  "<br>PC2: ", round(pca_data$PC2, 2)
)

# Create interactive PCA plot
plot_ly(
  data = pca_data,
  x = ~PC1,
  y = ~PC2,
  color = ~group,
  colors = group_colors,
  text = ~hover,
  type = 'scatter',
  mode = 'markers',
  marker = list(size = 10),
  hoverinfo = "text"
) %>%
  layout(
    title = "PCA Plot of Normalized Counts",
    xaxis = list(title = paste0("PC1 (", pca_var_exp[1], "%)")),
    yaxis = list(title = paste0("PC2 (", pca_var_exp[2], "%)")),
    legend = list(orientation = "h", x = 0.3, y = -0.15)
  )

# print(pca_plot)
```


## 3-D PCA plot

```{r plot_pca_3d_plotly}
#| code-fold: true
#| code-summary: "üß¨ 3D PCA Plot"
#| fig.width: 8
#| fig.height: 6
#| fig.cap: "3D PCA plot of normalized counts, colored by group"
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

# Create hover text
pca_data$hover <- paste0(
  "Sample: ", pca_data$sample,
  "<br>Group: ", pca_data$group,
  "<br>PC1: ", round(pca_data$PC1, 2),
  "<br>PC2: ", round(pca_data$PC2, 2),
  "<br>PC3: ", round(pca_data$PC3, 2)
)

# 3D interactive PCA plot
plot_ly(
  data = pca_data,
  x = ~PC1,
  y = ~PC2,
  z = ~PC3,
  color = ~group,
  colors = group_colors,
  text = ~hover,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 5),
  hoverinfo = "text"
) %>%
  layout(
    title = "3D PCA Plot of Normalized Counts",
    scene = list(
      xaxis = list(title = paste0("PC1 (", pca_var_exp[1], "%)")),
      yaxis = list(title = paste0("PC2 (", pca_var_exp[2], "%)")),
      zaxis = list(title = paste0("PC3 (", pca_var_exp[3], "%)"))
    ),
    legend = list(orientation = "h", x = 0.3, y = -0.1)
  )

# print(pca_3d_plot)
```

## DEG results

```{r design}
#| code-fold: true
#| code-summary: "üß© Design Matrix"

# Create design matrix
design <- model.matrix(as.formula(params$design_formula), data = selected_samples)
# Report design matrix  dimensions
print(glue::glue("üìä Design matrix dimensions: ", nrow(design), " samples √ó ", ncol(design), " variables"))
# Check for singularities
if (any(is.na(design))) {
  stop("‚ùå Design matrix contains NA values. Please check your samplesheet and design formula.")
}

# Estimate dispersion
dge <- estimateDisp(dge, design)

# Fit GLM and run LRT
fit <- glmFit(dge, design)
lrt <- glmLRT(fit)

# Save DE table
top_table <- topTags(lrt, n = Inf)$table

# Get test summary
summary(decideTests(lrt))
```

## MA Plot

```{r maplot}
#| code-fold: true
#| code-summary: "üìà MA Plot"
#| fig.width: 8
#| fig.height: 6
#| fig.cap: "MA plot of differential expression results"
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"

# Extract results table
res_table <- topTags(lrt, n = Inf)$table

# Add average logCPM expression (from the DGE object)
res_table$AveExpr <- rowMeans(cpm(dge, log = TRUE))

# Optionally, add a significance column for coloring
res_table$Significant <- ifelse(res_table$FDR < 0.05, "FDR < 0.05", "Not Sig")

# Interactive MA plot
ma_plot <- plot_ly(
  data = res_table,
  x = ~AveExpr,
  y = ~logFC,
  type = 'scatter',
  mode = 'markers',
  color = ~Significant,
  colors = c("gray", "red"),
  text = ~paste("Gene:", rownames(res_table),
                "<br>logFC:", round(logFC, 2),
                "<br>FDR:", signif(FDR, 3)),
  hoverinfo = "text"
) %>%
  layout(
    title = "üß¨ Interactive MA Plot",
    xaxis = list(title = "Average logCPM"),
    yaxis = list(title = "log2 Fold Change"),
    shapes = list(
      list(type = "line", x0 = min(res_table$AveExpr), x1 = max(res_table$AveExpr),
           y0 = 0, y1 = 0, line = list(dash = "dash", color = "black"))
    )
  )

# print plot
ma_plot
# print(ma_plot)
```

## Volcano Plot

```{r volcano_plotly_4color}
#| code-fold: true
#| code-summary: "üåã Interactive Volcano Plot (4 colors like EnhancedVolcano)"
#| fig.width: 8
#| fig.height: 10
#| fig.cap: "Interactive volcano plot mimicking EnhancedVolcano coloring"
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false

log2FC_threshold <- params$log2FC_threshold
pvalue_threshold <- params$pvalue_threshold

# Prepare data
volcano_df <- topTags(lrt, n = Inf)$table
volcano_df$gene <- rownames(volcano_df)
volcano_df$logP <- -log10(volcano_df$PValue)

# Categorize each gene
volcano_df$Significance <- "NS"  # Default: not significant
volcano_df$Significance[volcano_df$PValue < pvalue_threshold & abs(volcano_df$logFC) >= log2FC_threshold] <- "p-value and log2FC"
volcano_df$Significance[volcano_df$PValue < pvalue_threshold & abs(volcano_df$logFC) < log2FC_threshold] <- "p-value"
volcano_df$Significance[volcano_df$PValue >= pvalue_threshold & abs(volcano_df$logFC) >= log2FC_threshold] <- "Log2FC"

# Define custom colors
sig_colors <- c(
  "NS" = "gray",
  "Log2FC" = "#009E73",             # Green
  "p-value" = "#0072B2",            # Blue
  "p-value and log2FC" = "#D55E00"  # Red
)

# Create hover text
volcano_df$hover <- paste0(
  "Gene: ", volcano_df$gene,
  "<br>logFC: ", round(volcano_df$logFC, 2),
  "<br>FDR: ", signif(volcano_df$FDR, 3),
  "<br>PValue: ", signif(volcano_df$PValue, 3)
)

# Plot
volcano_plotly <- plot_ly(
  data = volcano_df,
  x = ~logFC,
  y = ~logP,
  type = "scatter",
  mode = "markers",
  color = ~Significance,
  colors = sig_colors,
  text = ~hover,
  hoverinfo = "text",
  marker = list(size = 6, line = list(width = 0.5, color = 'black'))
) %>%
  layout(
    title = list(text = paste0("Volcano Plot: ", g1, " vs ", g2)),
    xaxis = list(title = "log2 Fold Change"),
    yaxis = list(title = "-log10(P-value)"),
    legend = list(title = list(text = "Significance"), orientation = "h", x = 0.3, y = -0.2),
    shapes = list(
      # Horizontal line at -log10(0.05)
      list(type = "line", x0 = min(volcano_df$logFC), x1 = max(volcano_df$logFC),
           y0 = -log10(pvalue_threshold), y1 = -log10(pvalue_threshold),
           line = list(dash = "dot", width = 1, color = "black")),
      # Vertical line at logFC = -1
      list(type = "line", x0 = -1 * log2FC_threshold, x1 = -1 * log2FC_threshold,
           y0 = 0, y1 = max(volcano_df$logP),
           line = list(dash = "dot", width = 1, color = "black")),
      # Vertical line at logFC = 1
      list(type = "line", x0 = log2FC_threshold, x1 = log2FC_threshold,
           y0 = 0, y1 = max(volcano_df$logP),
           line = list(dash = "dot", width = 1, color = "black"))
    )
  )

volcano_plotly
```

# üíæ Save Results

```{r save_results}
#| code-fold: true
#| code-summary: "üíæ Save Results"
#| message: true
#| warning: false
top_table %>% rownames_to_column(var = "geneName" ) -> out_table

# Save the top table to a file
write.table(out_table, 
            file = params$deg_results_file, 
            sep = "\t", 
            quote = FALSE, 
            col.names = TRUE, 
            row.names = FALSE)
print(glue::glue("üíæ Differential expression results saved to: ", params$deg_results_file))
# Save as Excel (xlsx)
# Derive Excel filename by replacing .tsv or .txt with .xlsx
excel_file <- sub("\\.(tsv|txt)$", ".xlsx", params$deg_results_file)

# Write to Excel using openxlsx
openxlsx::write.xlsx(out_table, file = excel_file, asTable = TRUE)
print(glue::glue("üíæ Excel version of DE results saved to: ", excel_file))
```



