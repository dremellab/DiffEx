---
title: "Differential Gene Expression Analysis"
format:
  html:
    theme: flatly
    toc: true
    toc-location: left
    toc-depth: 4
execute:
  echo: false
  warning: false
  message: true
params:
  # counts_file: ".test/counts_matrix.tsv"
  # samplesheet: ".test/samples.tsv"
  # test dataset 2
  # counts_file: "~/Desktop/250424/counts_matrix.tsv"
  # samplesheet: "~/Desktop/250424/samples.tsv"
  # useERCC: TRUE
  # ercc_mix: 1 # choices: 1, 2
  # group1: "KOS"
  # group2: "Uninf"
  # sample_column: "sampleName"
  # group_column: "groupName"
  # batch: TRUE
  # batch_column: "batch"
  # design_formula: "~ groupName"
  # outdir: "~/Desktop/250424/results_250424"
  # test dataset 1
  counts_file: "~/Documents/Data/Analysis/20250423_RNAseq-1/counts/counts_matrix.tsv"
  samplesheet: "~/Documents/Data/Analysis/20250423_RNAseq-1/counts/samples.tsv"
  useERCC: FALSE
  ercc_mix: 1 # choices: 1, 2
  group1: "GFP48h"
  group2: "UT"
  sample_column: "sampleName"
  group_column: "groupName"
  batch: TRUE
  batch_column: "batch"
  design_formula: "~ groupName"
  outdir: "~/Documents/Data/Analysis/20250423_RNAseq-1/DiffEx_results"
  # normalized_counts_file: "normalized_counts.tsv"
  # deg_results_file: "deg_results.tsv"
  log2FC_threshold: 1.0 # use 1.0 and not 1 .. .to make it explicitly float for wrapping python package
  pvalue_threshold: 0.05
  fdr_threshold: 0.05
  edgeR_cpm_cutoff: 1.0 # use 1.0 and not 1 .. .to make it explicitly float for wrapping python package
  edgeR_cpm_group_fraction: 0.5
  DESeq2_low_count_cutoff: 2
  DESeq2_low_count_group_fraction: 0.5
  prerank_choice: "edgeR" # choices: "edgeR", "DESeq2", "combined"
  host: "Hs" # choices: "Hs", "Mm"
  genes_selection: "host" # choices: "host", "virus", "both" # filter out genes other than this selection
---

# 🔬 Differential Expression Analysis

This report performs standard DGE analysis using input count data, metadata, and user-defined contrasts.

---
```{r library}
#| code-fold: true
#| code-summary: "📦 Load Required Packages"
suppressPackageStartupMessages({
  library(limma)
  library(edgeR)
  library(DESeq2)
  library(tibble)
  library(readr)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(plotly)
  library(EnhancedVolcano)
  library(knitr)
  library(kableExtra)
  library(ggplotify)
  library(ggpubr)
  library(ggrepel)
  library(openxlsx)
  library(glue)
  library(DT)
  library(ComplexHeatmap)
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(org.Mm.eg.db)
  library(msigdbr)
  library(UpSetR)
  library(ggplot2)
  library(plotly)
  library(openxlsx)
  library(yaml)
  library(fs)
  library(VennDiagram)
  library(grid)
})

exit_gracefully <- function() {
  message("Exiting early: Debugging script intentionally halted.")
  knitr::knit_exit()
}
# Paths
output_base <- params$outdir
counts_dir <- file.path(output_base, "counts")
edger_deg_dir <- file.path(output_base, "edgeR_deg")
deseq2_deg_dir <- file.path(output_base, "DESeq2_deg")
limma_deg_dir <- file.path(output_base, "limma_deg")
# gsea_dir <- file.path(output_base, "gsea")

# Create folders
fs::dir_create(c(output_base,counts_dir, edger_deg_dir, deseq2_deg_dir,limma_deg_dir))

# write out params
# Convert Quarto parameters (params) to a named list
yaml_params <- as.list(params)

# Write to YAML file
yaml::write_yaml(yaml_params, file.path(output_base, "params_received.yaml"))
```

## Reading inputs

```{r readinput}
#| code-fold: true
#| code-summary: "📥 Read Count Matrix and Sample Sheet"
#| message: true
#| warning: false

print(glue::glue("📥 Reading input files: "))
print(glue::glue(params$counts_file, " and "))
print(glue::glue(params$samplesheet))

# Read the sample sheet
samples <- read.table(params$samplesheet, check.names = FALSE, sep = "\t", header = TRUE)
keep_cols <- c(params$sample_column, params$group_column)
if (isTRUE(params$batch)) {
  keep_cols <- c(keep_cols, params$batch_column)
}
# Find which of the required columns are actually present
present_cols <- intersect(keep_cols, colnames(samples))

# Check: all required columns must be present
if (length(present_cols) != length(keep_cols)) {
  missing_cols <- setdiff(keep_cols, present_cols)
  stop("❌ The following required columns are missing from 'samples': ", paste(missing_cols, collapse = ", "))
}

# Subset to the required columns
samples <- samples[, present_cols, drop = FALSE]

# Cleanup column values
samples[[params$sample_column]] <- gsub("-", "_", samples[[params$sample_column]])
samples[[params$group_column]]  <- gsub("-", "_", samples[[params$group_column]])

# Read the counts matrix
counts_data <- read.table(params$counts_file,
                     check.names = FALSE,  # prevent automatic conversion of hyphen to dot
                     row.names = 1, 
                     sep = "\t", 
                     header = TRUE)
colnames(counts_data) <- gsub("-", "_", colnames(counts_data))
sample_columns <- intersect(colnames(counts_data), samples[[params$sample_column]])
counts <- counts_data[, sample_columns, drop = FALSE]
original_counts <- counts
# Report original dimensions
print(glue::glue("📊 Counts matrix loaded: ", nrow(counts), " genes (rows) × ", ncol(counts), " samples (columns)"))

# Replace hyphens with underscores in column names
colnames(counts) <- gsub("-", "_", colnames(counts))


```

## Filtering counts matrix by samples in DEG groups

```{r filtercounts}
#| code-fold: true
#| code-summary: "🎯 Filter samples and counts matrix for selected groups"
#| message: true
#| warning: false

# Get groups from params
g1 <- params$group1
g2 <- params$group2

# Define color palette based on actual group names
group_colors <- setNames(c("#0072B2", "#D55E00"), c(g1, g2))

print(glue::glue("📥 Selecting samples in groups: "))
print(glue::glue(g1, " and "))
print(glue::glue(g2))

# Filter the samplesheet to only include samples from group1 and group2
selected_samples <- samples[samples[[params$group_column]] %in% c(g1, g2), ]

# Get the sample IDs (assuming there's a 'sample' column)
sample_ids <- selected_samples$sample

# Now subset the counts matrix
# Ensure sample columns in counts match sample IDs
filtered_counts <- counts[, colnames(counts) %in% sample_ids]
# Report dimensions
print(glue::glue("📦 Filtered counts matrix: ", nrow(filtered_counts), " genes × ", ncol(filtered_counts), " samples"))
```

## Filtering counts matrix by genes selection

```{r genes_selection}
#| code-fold: true
#| code-summary: "🔍 Filter by genes_selection"
#| message: true
#| warning: false

print(glue::glue("Genes selection: ", params$genes_selection))
print(glue::glue("useERCC: ", params$useERCC))

# Filter out genes based on the genes_selection
if (params$genes_selection == "host") {
  if (isTRUE(params$useERCC)) {
    # Select only host and ERCC genes
    if (params$host == "Hs") {
      filtered_counts <- filtered_counts[grepl("^ENSG|^ERCC", rownames(filtered_counts)), ]
    } else if (params$host == "Mm") {
      filtered_counts <- filtered_counts[grepl("^ENSMUSG|^ERCC", rownames(filtered_counts)), ]
    }
  } else {
    # Select only host genes no ERCC genes
    if (params$host == "Hs") {
      filtered_counts <- filtered_counts[grepl("^ENSG", rownames(filtered_counts)), ]
    } else if (params$host == "Mm") {
      filtered_counts <- filtered_counts[grepl("^ENSMUSG", rownames(filtered_counts)), ]
    }
  }
  nercc_genes <- nrow(filtered_counts[grepl("^ERCC", rownames(filtered_counts)), ])
  print(glue::glue("🦠 Host-only genes selected: ", nrow(filtered_counts), " genes remaining (including ", nercc_genes, " ERCC genes)"))
} else if (params$genes_selection == "virus") {
  if (isTRUE(params$useERCC)) {
    # Filter out host genes .. keep ERCC
    filtered_counts <- filtered_counts[!grepl("^ENS", rownames(filtered_counts)), ]
  } else {
    # Filter out host genes and ERCC genes
    filtered_counts <- filtered_counts[!grepl("^ERCC|^ENS", rownames(filtered_counts)), ]
  }
  nercc_genes <- nrow(filtered_counts[grepl("^ERCC", rownames(filtered_counts)), ])
  print(glue::glue("🦠 Virus-only genes selected: ", nrow(filtered_counts), " genes remaining (including ", nercc_genes, " ERCC genes)"))
} else if (params$genes_selection == "both") {
  if (!isTRUE(params$useERCC)) {
    # Keep both host and virus genes .. remove ERCC
    filtered_counts <- filtered_counts[grepl("^ERCC", rownames(filtered_counts)), ]
  }
  nercc_genes <- nrow(filtered_counts[grepl("^ERCC", rownames(filtered_counts)), ])
  print(glue::glue("🦠 Both host and virus genes included: ", nrow(filtered_counts), " genes remaining (including ", nercc_genes, " ERCC genes)"))
} else {
  stop("❌ Invalid mode selected. Choose 'host', 'virus', or 'both'.")
}
# Report dimensions
print(glue::glue("📦 Filtered counts matrix: ", nrow(filtered_counts), " genes × ", ncol(filtered_counts), " samples"))

counts <- filtered_counts
ready_for_deg_raw_counts <- counts
library_sizes <- colSums(counts)

# remove ERCCs genes which have zero reads in any sample
is_ercc <- grepl("^ERCC", rownames(counts))
ercc_counts <- counts[is_ercc, ]
nonzero_ercc_rows <- apply(ercc_counts, 1, function(x) all(x != 0))
is_nonzero_ercc <- rownames(counts) %in% rownames(ercc_counts)[nonzero_ercc_rows]
remove_ercc <- is_ercc & !is_nonzero_ercc

# update with selected nonzero ERCC genes
counts <- counts[!remove_ercc, ]
is_ercc <- grepl("^ERCC", rownames(counts))
is_endogenous <- !is_ercc


samples <- selected_samples
samples$groupName <- relevel(factor(samples[[params$group_column]], levels = c(g1, g2)),ref = g2)
#exit_gracefully()
if (isTRUE(params$useERCC)) {
  print(glue::glue("❌ Warning: ",sum(remove_ercc), " ERCC genes have ZERO counts in 1 or more samples and will be excluded!."))

  # Check if any ERCC genes have zero counts in all samples
  if (sum(is_nonzero_ercc) == 0) {
    stop("❌ All ERCC genes have zero counts in all samples. Please check your data or set useERCC to FALSE.")
  }
  print(glue::glue("✅ ", sum(is_nonzero_ercc), " ERCC genes have non-zero counts in all samples."))
} else {
  # useERCC is set to FALSE
  # Check if any ERCC genes have zero counts in all samples
  if (sum(is_ercc) > 0) {
    print(glue::glue("❌ ",sum(is_ercc)," ERCC genes are present but will be removed before analysis."))
  }
  counts <- counts[!is_ercc, ]
}
# Report dimensions
print(glue::glue("📦 Newly filtered counts matrix: ", nrow(counts), " genes × ", ncol(filtered_counts), " samples"))
```
## Validating group information

```{r validateinput}
#| code-fold: true
#| code-summary: "✅ Validate Contrast Groups"
#| message: true
#| warning: false
# Check unique group levels in the samplesheet
valid_groups <- unique(samples[[params$group_column]])

# Find missing groups
missing_groups <- setdiff(c(g1, g2), valid_groups)

if (length(missing_groups) > 0) {
  stop(paste0("❌ Group(s) from params not found in samples[[params$group_column]]\n",
       paste(missing_groups, collapse = ", ")))
} else {
  print(glue::glue("✅ Both group1(",g1,") and group2(",g2,") are present in samplesheet."))
  
  # Check if each group has at least 2 samples
  group_counts <- table(samples$groupName)
  too_few <- c()
  if (group_counts[g1] < 2) too_few <- c(too_few, g1)
  if (group_counts[g2] < 2) too_few <- c(too_few, g2)
  
  if (length(too_few) > 0) {
    stop("❌ The following group(s) have fewer than 2 samples:\n",
         paste(too_few, collapse = ", "))
  } else {
    print(glue::glue("✅ Each group has at least 2 samples."))
  }
}

```

```{r ercc_calculations}
#| code-fold: true
#| code-summary: "🧬 ERCC Calculations"
#| message: true
#| warning: false
#| echo: false

if (isTRUE(params$useERCC)) {

  # ercc_conc <- read.csv("/Users/vishal/Documents/GitRepos/DiffEx/diffex/assets/ERCC92_conc.txt", row.names = 1)
  # TODO: make this txt file part of DiffEx package
  ercc_url <- "https://raw.githubusercontent.com/mschertzer/ercc_analysis/refs/heads/master/ERCC92_conc.txt"
  
  # Read the tab-delimited ERCC file directly from GitHub
  ercc_conc <- read.delim(ercc_url, check.names = FALSE)
  colnames(ercc_conc) <- c("sortID",
                           "ERCC_ID",
                           "subgroup",
                           "Mix1_conc",
                           "Mix2_conc",
                           "FC_ratio",
                           "log2FC")
  
  # Filter the ERCC concentration data for the selected mix
  if (params$ercc_mix == 1) {
    ercc_conc <- ercc_conc[c("ERCC_ID", "Mix1_conc")]
  } else if (params$ercc_mix == 2) {
    ercc_conc <- ercc_conc[c("ERCC_ID", "Mix2_conc")]
  }
  colnames(ercc_conc) <- c("ERCC_ID", "ercc_conc")
  # make ERCC_ID the rownames after converting hyphen to underscore
  ercc_conc$ERCC_ID <- gsub("-", "_", ercc_conc$ERCC_ID)
  as.data.frame(ercc_conc) %>% column_to_rownames(var = "ERCC_ID") -> ercc_conc
  # calculated molecules from concentration
  ercc_conc$log2molecules <- log(ercc_conc$ercc_conc / 1000 * 20 * 6.022e5,2)
  
  counts_df <- as.data.frame(counts)
  counts_df$gene_id <- rownames(counts_df)
  
  counts_data$gene_id <- rownames(counts_data)
  
  merged_counts <- merge(counts_df,counts_data[,c("gene_id", "gene_length_kb")], by = "gene_id")
  as.data.frame(merged_counts) %>% column_to_rownames(var = "gene_id") -> merged_counts
  # merged_counts now has gene_length_kb as a column
  
    # Identify expression-only columns
  expr_cols <- setdiff(colnames(merged_counts), "gene_length_kb")
  
  # Compute RPKM
  rpkm_counts <- sweep(merged_counts[, expr_cols], 1, merged_counts$gene_length_kb, "/")  # divide by gene length
  rpkm_counts <- sweep(rpkm_counts, 2, library_sizes / 1e6, "/")  # divide by library size (in millions)

  # Log2-transform RPKM
  log2_rpkm_counts <- log2(rpkm_counts)

  # Subset ERCC rows
  ercc_rows <- grepl("^ERCC", rownames(log2_rpkm_counts))
  log2_ercc_counts <- log2_rpkm_counts[ercc_rows, ]
  
  # Remove -Inf and NA
  log2_ercc_counts <- log2_ercc_counts[!apply(log2_ercc_counts, 1, function(x) any(is.na(x) | is.infinite(x))), ]
  
  # Clean up rownames: keep only the first part before the '|'
  rownames(log2_ercc_counts) <- sub("\\|.*", "", rownames(log2_ercc_counts))

  common_erccs <- intersect(rownames(log2_ercc_counts), rownames(ercc_conc))
  
  counts_matched <- log2_ercc_counts[common_erccs, ]
  # reorder ercc_conc to match counts_matched
  ercc_conc <- ercc_conc[common_erccs, ]

  # Initialize results data frame
  ercc_qc <- data.frame(
    Sample = colnames(counts_matched),
    Slope = NA_real_,
    Intercept = NA_real_,
    Rsquared = NA_real_
  )
  
  # Fit linear model per sample
  for (s in colnames(counts_matched)) {
    y <- counts_matched[,s] # already log2 transformed RPKM values
    x <- ercc_conc$log2molecules
  
    fit <- lm(y ~ x)
    ercc_qc[ercc_qc$Sample == s, "Slope"]     <- coef(fit)[2]
    ercc_qc[ercc_qc$Sample == s, "Intercept"] <- coef(fit)[1]
    ercc_qc[ercc_qc$Sample == s, "Rsquared"]  <- summary(fit)$r.squared
  }

  # Create summary table
  ercc_norm_df <- data.frame(
    Sample = ercc_qc$Sample,
    Slope = format(ercc_qc$Slope, digits = 3),
    Intercept = format(ercc_qc$Intercept, digits = 3),
    Rsquared = format(ercc_qc$Rsquared, digits = 3)
  )
  
  DT::datatable(
    ercc_norm_df,
    caption = "📊 ERCC-Based Library Sizes and Intercept/Slope/R-squared",
    rownames = FALSE,
    options = list(pageLength = 20, autoWidth = TRUE)
  )
  
# Implement corrected log2RPKM = (log2RPKM - intercept) / slope (per sample)
pseudo_log2_normalized_counts <- log2_rpkm_counts

for (s in colnames(pseudo_log2_normalized_counts)) {
  intercept <- ercc_qc$Intercept[ercc_qc$Sample == s]
  slope <- ercc_qc$Slope[ercc_qc$Sample == s]

  # Sanity check
  if (length(intercept) != 1 || length(slope) != 1) {
    stop(glue::glue("❌ Could not uniquely match slope/intercept for sample {s}."))
  }

  # Apply transformation
  pseudo_log2_normalized_counts[, s] <- (pseudo_log2_normalized_counts[, s] - intercept) / slope
}

  
  pseudo_log2_normalized_counts[pseudo_log2_normalized_counts == -Inf] <- NA
}
```


```{r functions}
#| code-fold: true
#| code-summary: "🔧 Functions"
#| message: true
#| warning: false
#| echo: false

log2FC_threshold <- params$log2FC_threshold
pvalue_threshold <- params$pvalue_threshold
fdr_threshold <- params$fdr_threshold

make_violin_plot <- function(normalized_counts,
                             xlab = "Sample",
                             ylab = "Normalized Counts",
                             title = "Violin Plot of Normalized Counts by Sample") {

# Prepare data
violin_data <- as.data.frame(normalized_counts)

# Remove 'gene' column if it exists
if ("gene" %in% colnames(violin_data)) {
  violin_data$gene <- NULL
}

# Proceed to reshape data
violin_data <- violin_data %>%
  pivot_longer(
    cols = everything(),
    names_to = "sample",
    values_to = "normalized_counts"
  )

violin_data$group <- selected_samples[[params$group_column]][match(violin_data$sample, selected_samples[[params$sample_column]])]
violin_data$group <- factor(violin_data$group, levels = c(g1, g2))
violin_data$sample <- factor(violin_data$sample, levels = unique(violin_data$sample))
violin_data$normalized_counts <- as.numeric(violin_data$normalized_counts)
violin_data <- violin_data %>% filter(normalized_counts > 0)

# Plot
violin_plot <- ggplot(violin_data, aes(x = sample, y = normalized_counts, fill = group)) +
  geom_violin(scale = "width", trim = TRUE, alpha = 0.7) +
  geom_boxplot(width = 0.1, outlier.shape = 16, outlier.size = 1, alpha = 0.5) +
  scale_y_log10() +
  scale_fill_manual(values = group_colors) +
  theme_bw() +
  labs(
    title = title,
    x = xlab,
    y = ylab,
    fill = "Group"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    legend.position = "top"
  ) + coord_flip()
return(violin_plot)
}

make_pca_plots <- function(normalized_counts,
                           title = "PCA Plot of Normalized Counts"){

normalized_counts <- normalized_counts %>%
  as.data.frame() %>%
  {
    if ("gene" %in% colnames(.)) {
      rownames(.) <- NULL
      column_to_rownames(., var = "gene")
    } else {
      .  # assume rownames are already gene names
    }
  }

# Perform PCA
# Remove constant genes (zero variance across samples)
normalized_counts <- normalized_counts[apply(normalized_counts, 1, function(x) var(x) > 0), ]

# Then run PCA
pca <- prcomp(t(normalized_counts), center = TRUE, scale. = TRUE)

pca_data <- as.data.frame(pca$x)

# Calculate % variance explained
pca_var <- pca$sdev^2
pca_var_exp <- round(100 * pca_var / sum(pca_var), 1)

# Add group and sample info
pca_data$sample <- rownames(pca_data)
pca_data$group <- selected_samples[[params$group_column]][match(pca_data$sample, selected_samples[[params$sample_column]])]
pca_data$group <- factor(pca_data$group, levels = c(g1, g2))

# Create custom hover text
pca_data$hover <- paste0(
  "Sample: ", pca_data$sample,
  "<br>Group: ", pca_data$group,
  "<br>PC1: ", round(pca_data$PC1, 2),
  "<br>PC2: ", round(pca_data$PC2, 2)
)

# Create interactive PCA plot
pca2d <- plot_ly(
  data = pca_data,
  x = ~PC1,
  y = ~PC2,
  color = ~group,
  colors = group_colors,
  text = ~hover,
  type = 'scatter',
  mode = 'markers',
  marker = list(size = 10),
  hoverinfo = "text"
) %>%
  layout(
    title = title,
    xaxis = list(title = paste0("PC1 (", pca_var_exp[1], "%)")),
    yaxis = list(title = paste0("PC2 (", pca_var_exp[2], "%)")),
    legend = list(orientation = "h", x = 0.3, y = -0.15)
  )

# Create hover text
pca_data$hover <- paste0(
  "Sample: ", pca_data$sample,
  "<br>Group: ", pca_data$group,
  "<br>PC1: ", round(pca_data$PC1, 2),
  "<br>PC2: ", round(pca_data$PC2, 2),
  "<br>PC3: ", round(pca_data$PC3, 2)
)

# 3D interactive PCA plot
pca3d <- plot_ly(
  data = pca_data,
  x = ~PC1,
  y = ~PC2,
  z = ~PC3,
  color = ~group,
  colors = group_colors,
  text = ~hover,
  type = "scatter3d",
  mode = "markers",
  marker = list(size = 5),
  hoverinfo = "text"
) %>%
  layout(
    title = title,
    scene = list(
      xaxis = list(title = paste0("PC1 (", pca_var_exp[1], "%)")),
      yaxis = list(title = paste0("PC2 (", pca_var_exp[2], "%)")),
      zaxis = list(title = paste0("PC3 (", pca_var_exp[3], "%)"))
    ),
    legend = list(orientation = "h", x = 0.3, y = -0.1)
  )
    return(list(
    pca2d = pca2d,
    pca3d = pca3d
  ))
}

make_volcano_plot <- function(volcano_df,
                              pvalue_column_name = "PValue",
                              logFC_column_name = "logFC",
                              FDR_column_name = "FDR"
){

# remove all rows where Pvalue is NA
volcano_df <- volcano_df[!is.na(volcano_df[[pvalue_column_name]]), ]
# remove all rows where logFC is NA
volcano_df <- volcano_df[!is.na(volcano_df[[logFC_column_name]]), ]

# Rename logFC column to "logFC" if needed
if (logFC_column_name != "logFC") {
  names(volcano_df)[names(volcano_df) == logFC_column_name] <- "logFC"
}
if (pvalue_column_name != "PValue") {
  names(volcano_df)[names(volcano_df) == pvalue_column_name] <- "PValue"
}
if (FDR_column_name != "FDR") {
  names(volcano_df)[names(volcano_df) == FDR_column_name] <- "FDR"
}

volcano_df$logP <- -log10(volcano_df$PValue)

# Categorize each gene
volcano_df$Significance <- "NS"  # Default: not significant
volcano_df$Significance[volcano_df$PValue < pvalue_threshold & abs(volcano_df$logFC) >= log2FC_threshold] <- "p-value and log2FC"
volcano_df$Significance[volcano_df$PValue < pvalue_threshold & abs(volcano_df$logFC) < log2FC_threshold] <- "p-value"
volcano_df$Significance[volcano_df$PValue >= pvalue_threshold & abs(volcano_df$logFC) >= log2FC_threshold] <- "Log2FC"

# Define custom colors
sig_colors <- c(
  "NS" = "gray",
  "Log2FC" = "#009E73",             # Green
  "p-value" = "#0072B2",            # Blue
  "p-value and log2FC" = "red"  # Red
)

# Create hover text
volcano_df$hover <- paste0(
  "Gene: ", volcano_df$gene,
  "<br>logFC: ", round(volcano_df$logFC, 2),
  "<br>FDR: ", ifelse(is.na(volcano_df$FDR), NA, signif(volcano_df$FDR, 3)),
  "<br>PValue: ", signif(volcano_df$PValue, 3)
)

# Plot
volcano_plotly <- plot_ly(
  data = volcano_df,
  x = ~logFC,
  y = ~logP,
  type = "scatter",
  mode = "markers",
  color = ~Significance,
  colors = sig_colors,
  text = ~hover,
  hoverinfo = "text",
  marker = list(size = 6)
) %>%
  layout(
    title = list(text = paste0("Volcano Plot: ", g1, " vs ", g2)),
    xaxis = list(title = "log2 Fold Change"),
    yaxis = list(title = "-log10(P-value)"),
    legend = list(title = list(text = "Significance"), orientation = "h", x = 0.3, y = -0.2),
    shapes = list(
      # Horizontal line at -log10(0.05)
      list(type = "line", x0 = min(volcano_df$logFC), x1 = max(volcano_df$PValue),
           y0 = -log10(pvalue_threshold), y1 = -log10(pvalue_threshold),
           line = list(dash = "dot", width = 1, color = "black")),
      # Vertical line at logFC = -1
      list(type = "line", x0 = -1 * log2FC_threshold, x1 = -1 * log2FC_threshold,
           y0 = 0, y1 = max(volcano_df$logP),
           line = list(dash = "dot", width = 1, color = "black")),
      # Vertical line at logFC = 1
      list(type = "line", x0 = log2FC_threshold, x1 = log2FC_threshold,
           y0 = 0, y1 = max(volcano_df$logP),
           line = list(dash = "dot", width = 1, color = "black"))
    )
  )
return(volcano_plotly)
}

```



# limma analysis

## Normalization

```{r limma}
#| code-fold: true
#| code-summary: "📊 Limma Analysis"
#| message: true
#| warning: false
#| echo: false

if (isTRUE(params$useERCC)) {
  
  print(glue::glue("✅ ERCC standard curve slope - based normalization enabled."))
  dims <- dim(pseudo_log2_normalized_counts)
  print(glue::glue("📊 log2 normalized pseudo RPKM counts matrix dimensions: {dims[1]} genes × {dims[2]} samples"))
  # Use pseudo_log2_normalized_counts for limma analysis
  limma_design <- as.formula(sub("~\\s*", "~ 0 + ", params$design_formula))
  limma_model_matrix <- model.matrix(limma_design, data = samples)
  contrast_str <- paste0("groupName", params$group1, " - groupName", params$group2)
  contrast_matrix <- makeContrasts(contrasts = contrast_str, levels = limma_model_matrix)
  
  # fit the model
  fit <- lmFit(pseudo_log2_normalized_counts, limma_model_matrix)
  
  # run contrasts
  fit2 <- contrasts.fit(fit, contrast_matrix)
  fit2 <- eBayes(fit2)
  
  # Top DE genes for KOS vs Uninf
  top_genes <- topTable(fit2, number = Inf)
}
## TODO 
# } else {
#   # Use log2CPM counts for limma analysis
#   limma_design = as.formula(params$design_formula)
# }

```

```{r save_limma_normalized_counts}
#| code-fold: true
#| code-summary: "💾 Save Normalized Counts"
#| message: true
#| warning: false
# Save normalized counts to a file
as.data.frame(pseudo_log2_normalized_counts) %>%
  rownames_to_column(var = "gene") -> pseudo_log2_normalized_counts_for_output
normalized_counts_file <- file.path(counts_dir, "limma_log2normalized_pseudo_rpkm_counts.tsv")
write.table(pseudo_log2_normalized_counts_for_output,
            file = normalized_counts_file,
            sep = "\t",
            quote = FALSE,
            col.names = TRUE,
            row.names = FALSE)
print(glue::glue("💾 Normalized counts saved to: ", normalized_counts_file))

pseudo_rpkm_counts <- 2^pseudo_log2_normalized_counts/20000
pseudo_rpkm_counts[is.na(pseudo_rpkm_counts)] <- 0
pseudo_rpkm_counts_for_output <- as.data.frame(pseudo_rpkm_counts) %>%
  rownames_to_column(var = "gene")
pseudo_rpkm_counts_file <- file.path(counts_dir, "limma_pseudo_rpkm_counts.tsv")
write.table(pseudo_rpkm_counts_for_output,
            file = pseudo_rpkm_counts_file,
            sep = "\t",
            quote = FALSE,
            col.names = TRUE,
            row.names = FALSE)
# exit_gracefully()
```
## Count Distribution plot

::: {.panel-tabset}

### Before normalization
```{r limma_violin_before_norm}
#| code-fold: true
#| code-summary: "📊 Violin Plot of Normalized Counts"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"

  log2_rpkm_counts_for_plots <- log2_rpkm_counts[!apply(log2_rpkm_counts, 1, function(x) any(is.na(x) | is.infinite(x))), ]
as.data.frame(log2_rpkm_counts_for_plots) %>% rownames_to_column(var = "gene") -> log2_rpkm_counts_for_plots
  violin_plot <- make_violin_plot(log2_rpkm_counts_for_plots,
                                   xlab = "Sample",
                                   ylab = "Log2 RPKM Raw Counts",
                                   title = "")
violin_plot
```
### After normalization
```{r limma_violins}
#| code-fold: true
#| code-summary: "📊 Violin Plot of Normalized Counts"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"

pseudo_log2_normalized_counts_for_plots <- pseudo_log2_normalized_counts[!apply(pseudo_log2_normalized_counts, 1, function(x) any(is.na(x) | is.infinite(x))), ]

# Create violin plot of normalized counts
if (isTRUE(params$useERCC)) {
  violin_plot <- make_violin_plot(pseudo_log2_normalized_counts_for_plots,
                                   xlab = "Sample",
                                   ylab = "Log2 Normalized Pseudo RPKM Counts",
                                   title = "")
} else {
  # TODO
  pass
}
violin_plot
```
:::

## 2-D PCA plot

::: {.panel-tabset}

### Before normalization

```{r plot_pca_before_limma}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_before <- make_pca_plots(log2_rpkm_counts_for_plots,
                               title = "PCA Plot of Log2 RPKM Counts")
pcas_before$pca2d

# exit_gracefully()
# print(pca_plot)
```

### After normalization

```{r plot_pca_after_limma}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_after <- make_pca_plots(pseudo_log2_normalized_counts_for_plots,
                               title = "PCA Plot of Log2 Normalized Pseudo RPKM Counts")
pcas_after$pca2d

```

:::

## 3-D PCA plot

::: {.panel-tabset}

### Before normalization

```{r plot_3dpca_before_limma}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_before$pca3d

# exit_gracefully()
# print(pca_plot)
```

### After normalization

```{r plot_3dpca_after_limma}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_after$pca3d

# exit_gracefully()
# print(pca_plot)
```

:::

## DEG results

```{r deg_results_limma}
#| code-fold: true
#| code-summary: "📊 Top DE Genes from Limma Analysis"
#| message: true
#| warning: false
#| echo: false

pseudo_log2_normalized_counts <- 
    pseudo_log2_normalized_counts %>%
    as.data.frame() %>%
    {rownames(.) <- NULL; .} 

# Add average log2 expression per gene
top_genes$AveExpr <- rowMeans(pseudo_log2_normalized_counts[rownames(top_genes), , drop = FALSE])

# Categorize gene regulation direction
top_genes$Direction <- dplyr::case_when(
  top_genes$adj.P.Val < fdr_threshold & top_genes$logFC > log2FC_threshold ~ "Up",
  top_genes$adj.P.Val < fdr_threshold & top_genes$logFC < -log2FC_threshold ~ "Down",
  TRUE ~ "NotSig"
)

# Clean and format limma results, adding FoldChange
res_table_limma <- top_genes %>%
  rownames_to_column(var = "gene") %>%
  dplyr::select(gene, logFC, AveExpr, P.Value, adj.P.Val, Direction) %>%
  dplyr::rename(
    log2FoldChange = logFC,
    p_value = P.Value,
    FDR = adj.P.Val
  ) %>%
  dplyr::mutate(
    FoldChange = 2^log2FoldChange
  )

res_table_limma <- res_table_limma %>%
  dplyr::select(gene, log2FoldChange, FoldChange, AveExpr, p_value, FDR, Direction)

# Summary table
limma_deg_results_stats_df <- as.data.frame(table(top_genes$Direction))
colnames(limma_deg_results_stats_df) <- c("Direction", "No. of genes")
limma_deg_results_stats_df <- limma_deg_results_stats_df[match(c("Down", "NotSig", "Up"), limma_deg_results_stats_df$Direction), ]

# Write table to file
fs::dir_create(limma_deg_dir)
limma_deg_file <- file.path(limma_deg_dir, "limma_results.tsv")
write.table(res_table_limma,
            file = limma_deg_file,
            sep = "\t",
            quote = FALSE,
            col.names = TRUE,
            row.names = FALSE)

print(glue::glue("💾 limma DE results saved to: {limma_deg_file}"))

```

```{r limma_deg_stats}
#| code-fold: true
#| code-summary: "📊 Summary of Limma DE Results"
#| message: true
#| warning: false
#| echo: false

DT::datatable(
  limma_deg_results_stats_df,
  caption = "📊 Summary of Limma DEG Results",
  rownames = FALSE,
  options = list(pageLength = 20, autoWidth = TRUE)
)
```

## Volcano Plot

```{r volcano_plotly_4color_edger}
#| code-fold: true
#| code-summary: "🌋 Interactive Volcano Plot (4 colors like EnhancedVolcano)"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false


# Prepare data
volcano_plotly <- make_volcano_plot(res_table_limma,
                              pvalue_column_name = "p_value",
                              logFC_column_name = "log2FoldChange",
                              FDR_column_name = "FDR")


volcano_plotly
```




# edgeR analysis

## CPM Filtering

```{r cpmfilter}
#| code-fold: true
#| code-summary: "🔍 CPM Filtering for edgeR"
#| message: true
#| warning: false

if (isTRUE(params$useERCC)) {
  ready_for_deg_raw_counts <- round(pseudo_rpkm_counts)
}

dge <- DGEList(counts = ready_for_deg_raw_counts, samples = samples, group = samples$groupName)

cpm_mat <- cpm(dge, log = FALSE)
group <- dge$samples$group
keep_genes <- apply(cpm_mat, 1, function(row) {
  by_group <- split(row, group)
  group_pass <- sapply(by_group, function(vals) {
    mean(vals > params$edgeR_cpm_cutoff) >= params$edgeR_cpm_group_fraction
  })
  any(group_pass)
})

dge_filtered <- dge[keep_genes, , keep.lib.sizes = FALSE]

ercc_genes_kept <- grepl("^ERCC",rownames(dge_filtered))
nercc_genes_kept <- sum(ercc_genes_kept)
nendogenous_genes_kept <- sum(keep_genes) - nercc_genes_kept

print(glue::glue("CPM filtering Criteria: "))
print(glue::glue("Atleast ", params$edgeR_cpm_group_fraction * 100, "% of samples in any group must have CPM > ", params$edgeR_cpm_cutoff))
print(glue::glue("🔍 Endogenous genes after filtering: ", nendogenous_genes_kept))
print(glue::glue("🔍 ERCC genes after filtering: ", nercc_genes_kept))

# exit_gracefully()
```

## Apply Normalization

```{r setupdge}
#| code-fold: true
#| code-summary: "🧬 Set up DGE object"
#| message: true
#| warning: false

dge_final <- dge_filtered
dge_final <- calcNormFactors(dge_filtered)

if (isTRUE(params$useERCC)) {
  print(glue::glue("✅ Using ERCC-normalized pseudo RPKM counts from limma analysis."))
  dge_final$samples$norm.factors <- rep(1, ncol(dge_final))
} else {
  message("ℹ️ Using TMM normalization.")
}
```

```{r normfactor table, echo=FALSE}
#| code-fold: true
#| code-summary: "🧬 ERCC datatable"
#| message: true
#| warning: false
# Only run if normalization used ERCCs
  DT::datatable(
    as.data.frame(dge_final$samples) %>%
      rownames_to_column(var = "Sample") %>%
      mutate(
        Group = group,
        LibrarySize = lib.size,
        NormFactor = signif(norm.factors, 3)
      ) %>%
      dplyr::select(Sample, Group, LibrarySize, NormFactor),
    caption = "📊 Library Sizes and Normalization Factors",
    rownames = FALSE,
    options = list(pageLength = 20, autoWidth = TRUE)
  )
```

<!-- ## Norm Factor Plot -->

<!-- ```{r normfactorplot} -->
<!-- #| code-fold: true -->
<!-- #| code-summary: "📊 Normalization Factor Plot" -->
<!-- #| fig.width: 8 -->
<!-- #| fig.height: 6 -->
<!-- #| out.width: "100%" -->
<!-- #| out.height: "100%" -->
<!-- #| fig.align: "center" -->
<!-- #| fig.show: "hold" -->
<!-- #| warning: false -->
<!-- dge_samples_df <- as.data.frame(dge_final$samples) %>%  -->
<!--   rownames_to_column(var = "Sample") %>% -->
<!--   mutate( -->
<!--     Group = group, -->
<!--     LibrarySize = lib.size, -->
<!--     NormFactor = signif(norm.factors, 3) -->
<!--   ) %>% -->
<!--   dplyr::select(Sample, Group, LibrarySize, NormFactor) -->

<!-- # if original samples contains params$batch_column, add it to dge_samples_df -->
<!-- # Optionally add Batch to dge_samples_df -->
<!-- if (params$batch_column %in% colnames(samples)) { -->
<!--   dge_samples_df$Batch <- selected_samples[[params$batch_column]][match(dge_samples_df$Sample, selected_samples[[params$sample_column]])] -->
<!--   # Assign colors based on Batch -->
<!--   dge_samples_df$Color <- group_colors[dge_samples_df$Group] -->


<!-- # Step 1: Define available shapes and assign per batch -->
<!-- available_shapes <- c("circle", "square", "diamond", "cross", "x",  -->
<!--                       "triangle-up", "triangle-down", "triangle-left",  -->
<!--                       "triangle-right", "star") -->

<!-- batches <- unique(dge_samples_df$Batch) -->
<!-- batch_shapes <- setNames( -->
<!--   rep(available_shapes, length.out = length(batches)), -->
<!--   batches -->
<!-- ) -->

<!-- # Step 2: Create the plot -->
<!-- p <- plot_ly() -->

<!-- # Add real colored points (per group), no legend -->
<!-- p <- p %>% add_trace( -->
<!--   data = dge_samples_df, -->
<!--   x = ~LibrarySize, -->
<!--   y = ~NormFactor, -->
<!--   text = ~Sample, -->
<!--   type = "scatter", -->
<!--   mode = "markers", -->
<!--   marker = list( -->
<!--     color = dge_samples_df$Color, -->
<!--     symbol = unname(batch_shapes[dge_samples_df$Batch]) -->
<!--   ), -->
<!--   name="", -->
<!--   hoverinfo = "text", -->
<!--   showlegend = FALSE -->
<!-- ) -->

<!-- # Step 3: Add dummy black points for legend only -->
<!-- for (b in batches) { -->
<!--   shape <- batch_shapes[b] -->
<!--   p <- p %>% add_trace( -->
<!--     x = 0, y = 0,  # Off-plot dummy point -->
<!--     type = "scatter", -->
<!--     mode = "markers", -->
<!--     marker = list( -->
<!--       color = "black", -->
<!--       symbol = shape, -->
<!--       size = 5 -->
<!--     ), -->
<!--     name = b, -->
<!--     showlegend = TRUE, -->
<!--     hoverinfo = "none", -->
<!--     legendgroup = b -->
<!--   ) -->
<!-- } -->

<!-- # Step 4: Layout -->
<!-- p <- p %>% layout( -->
<!--   title = "Library Size vs Normalization Factor", -->
<!--   xaxis = list(title = "Library Size"), -->
<!--   yaxis = list(title = "Normalization Factor"), -->
<!--   legend = list(title = list(text = "Batch")) -->
<!-- ) -->

<!-- p -->

<!-- } else { -->

<!-- # Base plot setup -->
<!-- p <- plot_ly(dge_samples_df,  -->
<!--              x = ~LibrarySize,  -->
<!--              y = ~NormFactor,  -->
<!--              text = ~Sample,  -->
<!--              color = ~Group, -->
<!--              colors = group_colors, -->
<!--              type = "scatter",  -->
<!--              mode = "markers") -->

<!-- # Final layout -->
<!-- p <- p %>% layout( -->
<!--   title = "Library Size vs Normalization Factor", -->
<!--   xaxis = list(title = "Library Size"), -->
<!--   yaxis = list(title = "Normalization Factor") -->
<!-- ) -->

<!-- p -->

<!-- } -->

<!-- # exit_gracefully() -->
<!-- ``` -->



<!-- ## Sample Info -->

<!-- ```{r sample_table} -->
<!-- #| code-fold: true -->
<!-- #| code-summary: "📋 Sample Metadata with Library Sizes and Norm Factors" -->
<!-- #| warning: false -->
<!-- #| message: false -->

<!-- # Extract sample info from dge object -->
<!-- sample_info <- dge_final$samples %>% -->
<!--   tibble::rownames_to_column(var = "Sample") %>% -->
<!--   mutate( -->
<!--     Group = group, -->
<!--     LibrarySize = format(lib.size, big.mark = ","), -->
<!--     NormFactor = formatC(norm.factors, format = "f", digits = 3) -->
<!--   ) -->

<!-- if (params$batch_column %in% colnames(sample_info)) { -->
<!--   sample_info <- sample_info %>% -->
<!--     mutate(Batch = .[[params$batch_column]]) -->
<!-- } else { -->
<!--   sample_info <- sample_info %>% -->
<!--     mutate(Batch = NA) -->
<!-- } -->

<!-- sample_info <- sample_info %>% -->
<!--   dplyr::select(Sample, Group, LibrarySize, NormFactor, Batch) -->


<!-- DT::datatable( -->
<!--   sample_info, -->
<!--   options = list( -->
<!--     pageLength = 20, -->
<!--     autoWidth = TRUE, -->
<!--     columnDefs = list(list(className = 'dt-center', targets = "_all")) -->
<!--   ), -->
<!--   rownames = FALSE -->
<!-- ) -->

<!-- # exit_gracefully() -->

<!-- ``` -->

```{r save_normalized_counts}
#| code-fold: true
#| code-summary: "💾 Save Normalized Counts"
#| message: true
#| warning: false
# Save normalized counts to a file
normalized_counts <- cpm(dge_final, normalized.lib.sizes = TRUE, log = TRUE)
as.data.frame(normalized_counts) %>%
  rownames_to_column(var = "gene") -> normalized_counts_for_output
normalized_counts_file <- file.path(counts_dir, "edgeR_logCPM_counts.tsv")
write.table(normalized_counts_for_output,
            file = normalized_counts_file,
            sep = "\t",
            quote = FALSE,
            col.names = TRUE,
            row.names = FALSE)
print(glue::glue("💾 Normalized counts saved to: ", normalized_counts_file))
# exit_gracefully()
```

<!-- <!-- # 📊 Data Visualization --> -->
## Count Distribution plot

::: {.panel-tabset}

### Before normalization

```{r violin_before}
#| code-fold: true
#| code-summary: "🎻 Violin Plot of Raw Counts by Sample (Colored by Group)"
#| fig.width: 10
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false


# Before normalization (assumes raw counts, norm.factors = 1)
dge_raw <- dge_final
dge_raw$samples$norm.factors <- 1
logcpm_before <- cpm(dge_raw, log = TRUE)
logcpm_before <- logcpm_before %>% as.data.frame() %>% tibble::rownames_to_column("gene")

# Create violin plot
violin_plot <- make_violin_plot(logcpm_before,
                                 xlab = "Sample",
                                 ylab = "Counts (logCPM)",
                                 title = "")

print(violin_plot)
# exit_gracefully()
```

### After Normalization

```{r violin_after}
#| code-fold: true
#| code-summary: "🎻 Violin Plot of Raw Counts by Sample (Colored by Group)"
#| fig.width: 10
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false


# Create violin plot
violin_plot <- make_violin_plot(normalized_counts,
                                 xlab = "Sample",
                                 ylab = "Counts (logCPM)",
                                 title = "")

print(violin_plot)
```

:::

## 2-D PCA plot

::: {.panel-tabset}

### Before normalization

```{r edger_plot_pca_before}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_before <- make_pca_plots(logcpm_before)
pcas_before$pca2d

# exit_gracefully()
# print(pca_plot)
```

### After normalization

```{r edger_plot_pca_after}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_after <- make_pca_plots(normalized_counts)
pcas_after$pca2d

# exit_gracefully()
# print(pca_plot)
```

:::

## 3-D PCA plot

:::{.panel-tabset}

### Before normalization

```{r plot_pca_3d_before}
#| code-fold: true
#| code-summary: "🧬 3D PCA Plot"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false


pcas_before$pca3d
# exit_gracefully()
# print(pca_3d_plot)
```

### After normalization

```{r plot_pca_3d_after}
#| code-fold: true
#| code-summary: "🧬 3D PCA Plot"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false


pcas_after$pca3d
# exit_gracefully()
# print(pca_3d_plot)
```

:::

## DEG results

```{r design_deseq2}
#| code-fold: true
#| code-summary: "🧩 Design Matrix"


samples[[params$group_column]] <- relevel(factor(samples[[params$group_column]]), ref = g2)
# Create design matrix
design <- model.matrix(as.formula(params$design_formula), data = samples)
# Report design matrix  dimensions
print(glue::glue("📊 Design matrix dimensions: ", nrow(design), " samples × ", ncol(design), " variables"))
# Check for singularities
if (any(is.na(design))) {
  stop("❌ Design matrix contains NA values. Please check your samplesheet and design formula.")
}

# Estimate dispersion
dge <- estimateDisp(dge_final, design)

# Fit GLM and run LRT
fit <- glmFit(dge, design)
lrt <- glmLRT(fit)

# Extract results table
res_table_edger <- topTags(lrt, n = Inf)$table

# Add average logCPM expression (from the DGE object)
res_table_edger$AveExpr <- rowMeans(cpm(dge, log = TRUE))

# Categorize gene regulation direction
res_table_edger$Direction <- dplyr::case_when(
  res_table_edger$FDR < fdr_threshold & res_table_edger$logFC > log2FC_threshold ~ "Up",
  res_table_edger$FDR < fdr_threshold & res_table_edger$logFC < -log2FC_threshold ~ "Down",
  TRUE ~ "NotSig"
)

# Rename columns and add FoldChange
res_table_edger <- res_table_edger %>%
  dplyr::rename(
    log2FoldChange = logFC,
    p_value = PValue
  ) %>%
  dplyr::mutate(
    FoldChange = 2^log2FoldChange
  )


if (!"gene" %in% colnames(res_table_edger)) {
  res_table_edger <- res_table_edger %>% rownames_to_column(var = "gene")
}

# Select and order columns
res_table_edger <- res_table_edger %>%
  dplyr::select(gene, log2FoldChange, FoldChange, logCPM, LR, p_value, FDR, AveExpr, Direction)


# Create summary table
deg_results_stats_df <- as.data.frame(table(res_table_edger$Direction))
colnames(deg_results_stats_df) <- c("Direction", "No. of genes")

# Reorder rows to: Down, NotSig, Up
deg_results_stats_df <- deg_results_stats_df[match(c("Down", "NotSig", "Up"), deg_results_stats_df$Direction), ]

# write results table to file
results_file <- file.path(edger_deg_dir, "edgeR_results.tsv")
write.table(res_table_edger, 
            file = results_file, 
            sep = "\t", 
            quote = FALSE, 
            col.names = TRUE, 
            row.names = FALSE)

print(glue::glue("💾 edgeR DE results saved to: ", results_file))
```

```{r deg_results_table}
#| code-fold: true
#| code-summary: "📊 DE Results Table"
#| message: true
#| warning: false

DT::datatable(
  deg_results_stats_df,
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ),
  rownames = FALSE
)
# exit_gracefully()
```

## BCV Plot
```{r BCV_maplot}
#| code-fold: true
#| code-summary: "📈 edgeR BCV Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"

plotBCV(dge)
```

## MA Plot

```{r maplot}
#| code-fold: true
#| code-summary: "📈 MA Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"


# Optionally, add a significance column for coloring
res_table_edger$Significant <- ifelse(res_table_edger$FDR < fdr_threshold, paste0("FDR < ",fdr_threshold), "Not Sig")

# Interactive MA plot
ma_plot <- plot_ly(
  data = res_table_edger,
  x = ~AveExpr,
  y = ~log2FoldChange,
  type = 'scatter',
  mode = 'markers',
  color = ~Significant,
  colors = c("red", "gray"),
  text = ~paste("Gene:", rownames(res_table_edger),
                "<br>logFC:", round(log2FoldChange, 2),
                "<br>FDR:", signif(FDR, 3)),
  hoverinfo = "text"
) %>%
  layout(
    title = "🧬 Interactive MA Plot",
    xaxis = list(title = "Average logCPM"),
    yaxis = list(title = "log2 Fold Change"),
    shapes = list(
      list(type = "line", x0 = min(res_table_edger$AveExpr), x1 = max(res_table_edger$AveExpr),
           y0 = 0, y1 = 0, line = list(dash = "dash", color = "black"))
    )
  )

# print plot
ma_plot
# exit_gracefully()
# print(ma_plot)
```

## Volcano Plot

```{r volcano_plotly_4color_limma}
#| code-fold: true
#| code-summary: "🌋 Interactive Volcano Plot (4 colors like EnhancedVolcano)"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| warning: false


# Prepare data
volcano_df <- topTags(lrt, n = Inf)$table
volcano_df$gene <- rownames(volcano_df)
volcano_plotly <- make_volcano_plot(volcano_df,
                              pvalue_column_name = "PValue",
                              logFC_column_name = "logFC",
                              FDR_column_name = "FDR")


volcano_plotly
```

# DESeq2 analysis

## Low-count filtering

```{r lowcountfiltering}
#| code-fold: true
#| code-summary: "🧬 Low count filtering"
#| message: true
#| warning: false
#| echo: false


# get original filtered counts
if (isTRUE(params$useERCC)) {
  filtered_counts <- round(pseudo_rpkm_counts)
} 
counts <- filtered_counts

is_ercc <- grepl("^ERCC", rownames(counts))
is_endogenous <- !is_ercc
is_nonzero_ercc <- is_ercc & (rowSums(counts) > 0)

group <- samples[[params$group_column]]

keep_genes_deseq2 <- apply(counts, 1, function(row) {
  by_group <- split(row, group)
  group_pass <- sapply(by_group, function(vals) {
    mean(vals > params$DESeq2_low_count_cutoff) >= params$DESeq2_low_count_group_fraction
  })
  any(group_pass)
})

if (isTRUE(params$useERCC)) {
  keep_genes_deseq2 <- keep_genes_deseq2 | is_nonzero_ercc
}

nendogeneous_genes_kept <- sum(keep_genes_deseq2 & is_endogenous)
nercc_genes_kept <- sum(keep_genes_deseq2 & is_nonzero_ercc)
print(glue::glue("Low-count filtering Criteria: "))
print(glue::glue("Atleast ", params$DESeq2_low_count_group_fraction * 100, "% of samples in any group must have count > ", params$DESeq2_low_count_cutoff))
print(glue::glue("✅ Endogenous genes after filtering: ", nendogeneous_genes_kept))
# if (isTRUE(params$useERCC)) {
# print(glue::glue("✅ ERCC genes after filtering low count genes for DESeq2 analysis: ", nercc_genes_kept))
# }
```

```{r deseq2_normalization}
#| code-fold: true
#| code-summary: "🧬 DESEq2 Normalization"
#| message: true
#| warning: false
#| echo: false

design_formula <- as.formula(params$design_formula)
dds <- DESeqDataSetFromMatrix(countData = counts[keep_genes_deseq2, ], 
                              colData = samples, 
                              design = design_formula)

if (isTRUE(params$useERCC)) {
  print(glue("🧪 ERCC slope based normalization will be applied"))
  sizeFactors(dds) <- rep(1, ncol(dds))
} else {
  print(glue("📏 Default DESeq2 size factor normalization"))
  dds <- estimateSizeFactors(dds)
}

# Pull normalized library size (sizeFactors) and original library size
dds_samples_df <- as.data.frame(colData(dds)) %>%
  rownames_to_column(var = "Sample") %>%
  mutate(
    Group = groupName,
    LibrarySize = colSums(counts(dds)),
    NormFactor = signif(sizeFactors(dds), 3)
  ) %>%
  dplyr::select(Sample, Group, LibrarySize, NormFactor)

# Add Batch column and colors
if (params$batch && params$batch_column %in% colnames(samples)) {
  dds_samples_df$Batch <- selected_samples[[params$batch_column]][match(dds_samples_df$Sample, selected_samples[[params$sample_column]])]
  dds_samples_df$Color <- group_colors[dds_samples_df$Group]

  # Define shapes per batch
  available_shapes <- c("circle", "square", "diamond", "cross", "x", 
                        "triangle-up", "triangle-down", "triangle-left", 
                        "triangle-right", "star")
  batches <- unique(dds_samples_df$Batch)
  batch_shapes <- setNames(
    rep(available_shapes, length.out = length(batches)),
    batches
  )

  # Base plot
  p <- plot_ly()

  # Real points (color by group, shape by batch)
  p <- p %>% add_trace(
    data = dds_samples_df,
    x = ~LibrarySize,
    y = ~NormFactor,
    text = ~Sample,
    type = "scatter",
    mode = "markers",
    marker = list(
      color = dds_samples_df$Color,
      symbol = unname(batch_shapes[dds_samples_df$Batch]),
      size = 6
    ),
    name="", # prevents 'trace 0' from showing in hover
    showlegend = FALSE
  )

  # Dummy points for legend (black, shape only)
  for (b in batches) {
    shape <- batch_shapes[b]
    p <- p %>% add_trace(
      x = 0, y = 0,
      type = "scatter",
      mode = "markers",
      marker = list(
        color = "black",
        symbol = shape,
        size = 6
      ),
      name = b,
      showlegend = TRUE,
      hoverinfo = "none",
      legendgroup = b
    )
  }

  # Layout
  p <- p %>% layout(
    title = "Library Size vs Normalization Factor (DESeq2)",
    xaxis = list(title = "Library Size"),
    yaxis = list(title = "Size Factor"),
    legend = list(title = list(text = "Batch"))
  )
} else {
  # Simple plot without batch encoding
  p <- plot_ly(dds_samples_df,
               x = ~LibrarySize,
               y = ~NormFactor,
               text = ~Sample,
               color = ~Group,
               colors = group_colors,
               type = "scatter",
               mode = "markers",
               marker = list(size = 6))

  p <- p %>% layout(
    title = "Library Size vs Normalization Factor (DESeq2)",
    xaxis = list(title = "Library Size"),
    yaxis = list(title = "Size Factor")
  )
}

p

```

```{r deseq2_sampleinfo}
#| code-fold: true
#| code-summary: "📋 DESeq2 Sample Metadata with Library Sizes and Norm Factors"
#| warning: false
#| message: false
#| echo: false

# Extract sample info from DESeq2 object
sample_info_deseq2 <- as.data.frame(colData(dds)) %>%
  rownames_to_column(var = "Sample") %>%
  mutate(
    Group = group,
    LibrarySize = format(colSums(counts(dds)), big.mark = ","),
    NormFactor = formatC(sizeFactors(dds), format = "f", digits = 3),
    Batch = if ("Batch" %in% names(.)) Batch 
          else if ("batch" %in% names(.)) batch 
          else NA
  ) %>%
  dplyr::select(Sample, Group, LibrarySize, NormFactor, Batch)

DT::datatable(
  sample_info_deseq2,
  options = list(
    pageLength = 20,
    autoWidth = TRUE,
    columnDefs = list(list(className = 'dt-center', targets = "_all"))
  ),
  rownames = FALSE
)
# exit_gracefully()
```

```{r save_deseq2_normalized_counts}
#| code-fold: true
#| code-summary: "💾 Save DESeq2 Normalized Counts"
#| message: true
#| warning: false
#| echo: false


# Run VST and extract assay
vst_obj <- vst(dds, blind = TRUE)
normalized_counts_deseq2 <- assay(vst_obj) %>% as.data.frame()

# Add gene column only if not present
normalized_counts_deseq2_for_output <- normalized_counts_deseq2 %>%
  tibble::rownames_to_column(var = "gene")

# Define output file path
normalized_counts_deseq2_file <- file.path(counts_dir, "DESeq2_vst_normalized_counts.tsv")

# Write to file
write.table(normalized_counts_deseq2_for_output,
            file = normalized_counts_deseq2_file,
            sep = "\t",
            quote = FALSE,
            col.names = TRUE,
            row.names = FALSE)

print(glue::glue("💾 DESeq2 normalized counts saved to: {normalized_counts_deseq2_file}"))

```

## Normalized counts Distribution plot

:::{.panel-tabset}

### Before normalization

```{r violin_deseq2_before}
#| code-fold: true
#| code-summary: "🎻 Violin Plot of Raw Counts by Sample (Colored by Group)"
#| fig.width: 10
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"

# BEFORE normalization (raw counts)
raw_counts <- counts(dds, normalized = FALSE)
logcounts_before <- log2(raw_counts + 1)
logcounts_before_df <- as.data.frame(logcounts_before) %>% tibble::rownames_to_column("gene")


# Create violin plot
violin_plot_deseq2 <- make_violin_plot(logcounts_before_df,
                                        xlab = "Sample",
                                        ylab = "Raw Counts(log2)",
                                        title = "")
                                        

print(violin_plot_deseq2)
# exit_gracefully()                            
```

### After normalization

```{r violin_deseq2_after}
#| code-fold: true
#| code-summary: "🎻 Violin Plot of VST Counts by Sample (Colored by Group)"
#| fig.width: 10
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"


# Create violin plot
violin_plot_deseq2 <- make_violin_plot(normalized_counts_deseq2,
                                        xlab = "Sample",
                                        ylab = "VST Normalized Counts",
                                        title = "")
                                        

print(violin_plot_deseq2)
# exit_gracefully()                            
```

:::

## 2-D PCA plot

::: {.panel-tabset}

### Before normalization

```{r plot_pca_plotly_deseq2_before}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_deseq2_before <- make_pca_plots(logcounts_before_df)
pcas_deseq2_before$pca2d

# exit_gracefully()
# print(pca_plot)
```

### After normalization

```{r plot_pca_plotly_deseq2_after}
#| code-fold: true
#| code-summary: "🧬 PCA Plot with Group Colors and Variance Labels"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false

pcas_deseq2_after <- make_pca_plots(normalized_counts_deseq2)
pcas_deseq2_after$pca2d

# exit_gracefully()
# print(pca_plot)
```

:::

## 3-D PCA plot

::: {.panel-tabset}

### Before normalization

```{r plot_pca_3d_plotly_deseq2_before}
#| code-fold: true
#| code-summary: "🧬 3D PCA Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false


pcas_deseq2_before$pca3d
# exit_gracefully()
# print(pca_3d_plot)
```

### After normalization

```{r plot_pca_3d_plotly_deseq2_after}
#| code-fold: true
#| code-summary: "🧬 3D PCA Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"
#| warning: false


pcas_deseq2_after$pca3d
# exit_gracefully()
# print(pca_3d_plot)
```

:::

## DEG results

```{r deseq2_results}
#| code-fold: true
#| code-summary: "🧩 DESeq2 Results"
#| message: true
#| warning: false
#| echo: false

# Run DESeq2 analysis
dds <- DESeq(dds)

# Extract the variable name from formula string
design_variable <- trimws(gsub("~", "", params$design_formula))

# Construct contrast vector
contrast_vector <- c(design_variable, g1, g2)

# Run DESeq2 results with contrast
res <- results(dds, contrast = contrast_vector)
# Add gene names
res$gene <- rownames(res)
# Save DESeq2 results to a file
res_file <- file.path(deseq2_deg_dir, "DESeq2_results.tsv")
write.table(res, 
            file = res_file, 
            sep = "\t", 
            quote = FALSE, 
            col.names = TRUE, 
            row.names = TRUE)
print(glue::glue("💾 DESeq2 results saved to: ", res_file))

# Assume 'res' is your DESeq2 results object
res_table_deseq2 <- as.data.frame(res)

# Add gene IDs as a column (if rownames are gene IDs)
res_table_deseq2$gene <- rownames(res_table_deseq2)

# Categorize gene direction
res_table_deseq2$Direction <- case_when(
  !is.na(res_table_deseq2$padj) & res_table_deseq2$padj < fdr_threshold & res_table_deseq2$log2FoldChange >  log2FC_threshold ~ "Up",
  !is.na(res_table_deseq2$padj) & res_table_deseq2$padj < fdr_threshold & res_table_deseq2$log2FoldChange < -log2FC_threshold ~ "Down",
  TRUE ~ "NotSig"
)

# Format DESeq2 results to match edgeR column structure
res_table_deseq2 <- res_table_deseq2 %>%
  dplyr::rename(
    p_value = pvalue,
    FDR = padj
  ) %>%
  dplyr::mutate(
    FoldChange = 2^log2FoldChange
  ) %>%
  dplyr::select(gene, log2FoldChange, FoldChange, baseMean, p_value, FDR, Direction)


# Create summary stats table
deg_results_stats_df_deseq2 <- as.data.frame(table(res_table_deseq2$Direction))
colnames(deg_results_stats_df_deseq2) <- c("Direction", "No. of genes")

# Reorder
deg_results_stats_df_deseq2 <- deg_results_stats_df_deseq2[match(c("Down", "NotSig", "Up"), deg_results_stats_df_deseq2$Direction), ]
```

```{r show_deseq2_results}
#| code-fold: true
#| code-summary: "📊 DESeq2 Results Summary"
#| message: false
#| warning: false
#| echo: false

# Show interactive table
DT::datatable(deg_results_stats_df_deseq2, rownames = FALSE, 
              options = list(
                pageLength = 10,
                autoWidth = TRUE,
                columnDefs = list(list(className = 'dt-center', targets = "_all"))))

```

## Dispersion Plot
```{r deseq2_dispersionplot}
#| code-fold: true
#| code-summary: "📈 DESeq2 Dispersion Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"

plotDispEsts(dds, main = "Dispersion Estimates (DESeq2)")
```

## MA Plot
```{r deseq2_maplot}
#| code-fold: true
#| code-summary: "📈 DESeq2 MA Plot"
#| fig.width: 8
#| fig.height: 6
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"
#| fig.show: "hold"

plotMA(res, main = "MA Plot (DESeq2)", ylim = c(-5, 5), alpha = 0.05)
```

## Volcano Plot

```{r volcano_plotly_deseq2}
#| code-fold: true
#| code-summary: "🌋 Interactive Volcano Plot (DESeq2)"
#| fig.width: 8
#| fig.height: 10
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"

# Prepare data
volcano_df_deseq2 <- res_table_deseq2
volcano_df_deseq2$gene <- rownames(volcano_df_deseq2)
volcano_plotly <- make_volcano_plot(volcano_df_deseq2,
                              pvalue_column_name = "p_value",
                              logFC_column_name = "log2FoldChange",
                              FDR_column_name = "FDR")
#
volcano_plotly
```


# Combined DEG Results

## Results table

```{r combined_results}
#| code-fold: true
#| code-summary: "🧬 Combined DEG Results"
#| message: true
#| warning: false
#| echo: false

res_table_limma <- res_table_limma %>%
  dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction)

res_table_edger <- res_table_edger %>%
  dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction)

res_table_deseq2 <- res_table_deseq2 %>%
  dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction)

# Combine edgeR, DESeq2, and limma DEG results by gene
combined_results <- res_table_edger %>%
  dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction) %>%
  dplyr::rename_with(~ paste0(.x, "_edgeR"), -gene) %>%
  dplyr::full_join(
    res_table_deseq2 %>%
      dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction) %>%
      dplyr::rename_with(~ paste0(.x, "_DESeq2"), -gene),
    by = "gene"
  ) %>%
  dplyr::full_join(
    res_table_limma %>%
      dplyr::select(gene, log2FoldChange, FoldChange, p_value, FDR, Direction) %>%
      dplyr::rename_with(~ paste0(.x, "_limma"), -gene),
    by = "gene"
  )

# Replace empty strings with NA (for safety)
combined_results[combined_results == ""] <- NA

output_file <- file.path(output_base, "combined_deg_results.tsv")
write.table(combined_results, 
            file = output_file, 
            sep = "\t", 
            quote = FALSE, 
            col.names = TRUE, 
            row.names = FALSE)
print(glue::glue("💾 Combined results saved to: ", output_file))

combined_results <- combined_results %>%
  dplyr::mutate(
    Direction_edgeR = ifelse(is.na(Direction_edgeR), "NotSig", Direction_edgeR),
    Direction_DESeq2 = ifelse(is.na(Direction_DESeq2), "NotSig", Direction_DESeq2),
    Direction_limma = ifelse(is.na(Direction_limma), "NotSig", Direction_limma)
  )
# Summarize DEG directions per method dynamically
direction_summary <- data.frame(
  Direction = c("Down", "NotSig", "Up"),
  edgeR = as.vector(table(factor(combined_results$Direction_edgeR, levels = c("Down", "NotSig", "Up")))),
  DESeq2 = as.vector(table(factor(combined_results$Direction_DESeq2, levels = c("Down", "NotSig", "Up")))),
  limma = as.vector(table(factor(combined_results$Direction_limma, levels = c("Down", "NotSig", "Up"))))
)

# Show as interactive datatable
DT::datatable(
  direction_summary,
  rownames = FALSE,
  options = list(pageLength = 5, dom = 't', ordering = FALSE),
  caption = 'Summary of DEG Direction by Method'
)

```

```{r upsetr_combined_results}
#| code-fold: true
#| code-summary: "🧬 UpSetR for Combined DEG Results"
#| message: false
#| warning: false
#| echo: false
#| fig.width: 8
#| fig.height: 8
#| out.width: "100%"
#| out.height: "100%"
#| fig.align: "center"

# Define up/down sets
edger_up   <- na.omit(combined_results$gene[combined_results$Direction_edgeR == "Up"])
edger_down <- na.omit(combined_results$gene[combined_results$Direction_edgeR == "Down"])
deseq2_up   <- na.omit(combined_results$gene[combined_results$Direction_DESeq2 == "Up"])
deseq2_down <- na.omit(combined_results$gene[combined_results$Direction_DESeq2 == "Down"])
limma_up   <- na.omit(combined_results$gene[combined_results$Direction_limma == "Up"])
limma_down <- na.omit(combined_results$gene[combined_results$Direction_limma == "Down"])

# Create named list of 6 sets
venn_sets <- list(
  edgeR_Up = edger_up,
  edgeR_Down = edger_down,
  DESeq2_Up = deseq2_up,
  DESeq2_Down = deseq2_down,
  limma_Up = limma_up,
  limma_Down = limma_down
)

# Use UpSetR for better readability with 6 sets
library(UpSetR)
venn_input <- fromList(venn_sets)
UpSetR::upset(venn_input, nsets = 6, order.by = "freq", main.bar.color = "#377eb8", sets.bar.color = "#e41a1c")
```


<!-- ```{r exit} -->
<!-- exit_gracefully() -->
<!-- print(glue::glue(" Exiting early: Debugging script intentionally halted.")) -->
<!-- ``` -->

